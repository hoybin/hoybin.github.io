<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>&#39;NOTES</title>
  
  <subtitle>一只程序猿的修行笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hoybin.github.io/"/>
  <updated>2019-02-01T06:36:13.030Z</updated>
  <id>http://hoybin.github.io/</id>
  
  <author>
    <name>Hoybin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript 函数</title>
    <link href="http://hoybin.github.io/archive/20190130-b38362de.html"/>
    <id>http://hoybin.github.io/archive/20190130-b38362de.html</id>
    <published>2019-01-30T12:29:57.000Z</published>
    <updated>2019-02-01T06:36:13.030Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 中的函数不是语言结构，而是一种数据（对象），只是这种数据同时也是可执行代码，所以 JavaScript 函数兼具两种属性：代码属性和数据属性。</p><p>函数可以执行，这不难理解，也很常见；数据属性才是 JavaScript 与众不同之处，也是 JavaScript 灵活强大的秘密武器。所以，JavaScript 也提供了创建函数对象的构造方法 —— <code>Function()</code>，如下示例：</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"console.log('Hello, world')"</span>);</span><br><span class="line">hello(); <span class="comment">// Hello, world</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"return x + y"</span>);</span><br><span class="line">sum(<span class="number">3</span>, <span class="number">9</span>); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>上面的例子充分展示了函数对象的数据本质，然而实际中极少使用，原因有两点：</p><ul><li>不符合传统编程习惯，书写起来比较麻烦，可读性也不高；</li><li>代码表示成字符串就逃过了编译阶段的检查机制，任何语法错误无法被捕获。</li></ul><p>因此，这种方法不被推荐，正确定义函数的方法是使用<strong>函数声明</strong>或者<strong>函数表达式</strong>。</p><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">[arg1,[, arg2,[..., argN]]]</span>) </span>&#123;</span><br><span class="line">   [statements]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是定义函数的标准姿势，这种方法大家应该都知道，不用太多解释。需要说明的是：函数是数据这个事实直接导致 —— <strong>函数名只是一个变量</strong>，其中存储的是对函数对象的引用（指针），其本质跟其他变量没有区别。看如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello, baby'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fa = hello; <span class="comment">// 将 heelo 赋值给 fa —— 传递指针</span></span><br><span class="line"><span class="keyword">var</span> fb = fa;   <span class="comment">// 将 fa 赋值给 fb —— 传递指针</span></span><br><span class="line">fa();         <span class="comment">// 输出：Hello, baby</span></span><br><span class="line">fa = <span class="literal">null</span>;   <span class="comment">// 销毁 fa —— 切断 fa 与函数对象的联系</span></span><br><span class="line">fa();       <span class="comment">// 报错：TypeError: fa is not a function</span></span><br><span class="line">fb();      <span class="comment">// 输出：Hello, baby —— 函数依然可用</span></span><br></pre></td></tr></table></figure><p>由此可以得出另外一个结论：在 JavaScript 中，<strong>函数没有重载</strong> —— 如果有多个命名相同的函数，那么先出现的定义将被后出现的定义覆盖，这并不会导致错误。</p><h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function [name]([arg1[, arg2[, ..., argN]]]) &#123;</span><br><span class="line">   [statements]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数表达式的语法和函数声明的语法非常相似，唯一不同的是函数表达式中 function 关键字后面的 name 是可选的。如果省略，称为<strong>匿名函数表达式</strong>；反之，称为<strong>命名函数表达式</strong>。</p><p>如下代码<strong>使用匿名函数表达式定义函数</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello, baby'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>命名函数表达式中的名称只在函数内部有效</strong>，如以下代码中的 hello：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fooname = <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello, baby'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">hello(); <span class="comment">// ReferenceError: hello is not defined</span></span><br><span class="line">fooname(); <span class="comment">// Hello, baby</span></span><br></pre></td></tr></table></figure><p>定义函数通常使用匿名函数表达式，如果需要在函数内部引用自身则可以使用命名函数表达式 —— 最常见的就是递归调用。</p><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        &#123;<span class="keyword">return</span> num * factorial(num<span class="number">-1</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个经典的递归阶乘函数，看起没什么问题，但下面的代码却可能导致它出错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherFactorial = factorial;</span><br><span class="line">factorial = <span class="literal">null</span>;</span><br><span class="line">alert(anotherFactorial(<span class="number">4</span>)); <span class="comment">// ERROR!</span></span><br></pre></td></tr></table></figure><p>可以使用命名函数表达式解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        &#123;<span class="keyword">return</span> num * f(num<span class="number">-1</span>);&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>另外，在函数体内也可以通过 arguments.callee 引用自身，但这是一种过时的方法。</p><h2 id="理解函数表达"><a href="#理解函数表达" class="headerlink" title="理解函数表达"></a>理解函数表达</h2><p>函数表达式的用法非常灵活，各种奇怪的写法经常让初学者看得眼花缭乱，再加上表达式的概念本身比较抽象，各种资料中解释的也很模糊，有的甚至避而不谈，导致这部分很难掌握。既然概念抽象，我想我也没本事解释的很清楚，直接说编码规则：</p><p><strong>函数表达式需要组合使用其他运算符才有效</strong>：<code>function [name](){...}</code> 不能单独出现在顶级代码中，单独出现的命名函数表达式就是函数声明，单独出现的匿名函数表达式会报错（解析器认为这是一个函数声明，但是又没有名字）。</p><p>是不是有些明白，还差一点，那就换个角度思考 —— 既然函数是一种数据，那么<strong>函数表达式就可以出现在任何普通数据可以出现的地方</strong>。前面两个小节中已经给出了最显而易见的用法 —— 将函数表达式赋值给一个变量，接下来再看些示例。</p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>回调函数就是<strong>将函数作为参数传递给另外一个函数</strong>来调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> invoke = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> callback(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">invoke(<span class="number">8</span>, <span class="number">17</span>, add); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><p>可以改写成匿名回调，这种用法最常见：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> invoke = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> callback(a, b);</span><br><span class="line">&#125;</span><br><span class="line">invoke(<span class="number">8</span>, <span class="number">17</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;<span class="keyword">return</span> x + y;&#125;);</span><br></pre></td></tr></table></figure><p>上面最后一行代码更常用的书写格式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">invoke(<span class="number">8</span>, <span class="number">17</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="即时函数（立即执行函数）"><a href="#即时函数（立即执行函数）" class="headerlink" title="即时函数（立即执行函数）"></a>即时函数（立即执行函数）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="function"><span class="keyword">function</span>(<span class="params">who</span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'Hello, '</span> + who)&#125;;</span><br><span class="line">hello(<span class="string">'Jack'</span>);</span><br></pre></td></tr></table></figure><p>以上代码定义了一个函数，然后稍微改变以下调用形式 —— 函数名字加上括号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(hello)(<span class="string">'Jack'</span>); <span class="comment">// 或者 (hello('Jack'))，两种方式均可</span></span><br></pre></td></tr></table></figure><p>将函数名字替换成定义函数的表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">who</span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'Hello, '</span> + who)&#125;)(<span class="string">'Jack'</span>);</span><br></pre></td></tr></table></figure><p>改写成常见格式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello, '</span> + who)</span><br><span class="line">&#125;)(<span class="string">'Jack'</span>);</span><br></pre></td></tr></table></figure><p>前面说过，函数表达式无法单独出现在顶级代码中，所以这里需要组合 <code>()</code> 使其成为合法代码，紧随其后的一对括号（函数调用运算符）将立即调用它前面的函数并传入参数（如果有参数）。</p><h2 id="返回函数的函数"><a href="#返回函数的函数" class="headerlink" title="返回函数的函数"></a>返回函数的函数</h2><p>函数既然数据，当然也可以作为函数的返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calculator = <span class="function"><span class="keyword">function</span>(<span class="params">operator</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(operator) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span> : <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;<span class="keyword">return</span> x + y&#125;; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span> : <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;<span class="keyword">return</span> x - y&#125;; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span> : <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;<span class="keyword">return</span> x * y&#125;; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span> : <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;<span class="keyword">return</span> x / y&#125;; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>  : <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下调用方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = calculator(<span class="string">'+'</span>);</span><br><span class="line">add(<span class="number">9</span>, <span class="number">5</span>); <span class="comment">// 14</span></span><br><span class="line"><span class="keyword">var</span> div = calculator(<span class="string">'/'</span>);</span><br><span class="line">div(<span class="number">9</span>, <span class="number">5</span>); <span class="comment">// 1.8</span></span><br></pre></td></tr></table></figure><p>还可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">calculator(<span class="string">'-'</span>)(<span class="number">9</span>, <span class="number">5</span>); <span class="comment">// 4</span></span><br><span class="line">calculator(<span class="string">'*'</span>)(<span class="number">9</span>, <span class="number">5</span>); <span class="comment">// 45</span></span><br></pre></td></tr></table></figure><h2 id="重写自身的函数"><a href="#重写自身的函数" class="headerlink" title="重写自身的函数"></a>重写自身的函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myfunc = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello, world'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello, baby'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">return</span> run;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>以上代码中，在立即函数内部定义了两个函数并调用了其中的 init 函数，最后返回函数 run。因为函数最后的返回结果是 run，第一行的赋值语句就变成了 <code>var myfunc = run</code>，所以 <code>Hello, world</code>  只会在代码载入时输出一次，其后在此调用 myfunc() 将输出 <code>Hello, baby</code>。以上代码可以简化为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myfunc = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello, world'</span>);</span><br><span class="line">    &#125;)();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello, baby'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 中的函数不是语言结构，而是一种数据（对象），只是这种数据同时也是可执行代码，所以 JavaScript 函数兼具两种属性：代码属性和数据属性。&lt;/p&gt;
&lt;p&gt;函数可以执行，这不难理解，也很常见；数据属性才是 JavaScript 与众不同之处，也是 JavaScript 灵活强大的秘密武器。所以，JavaScript 也提供了创建函数对象的构造方法 —— &lt;code&gt;Function()&lt;/code&gt;，如下示例：&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://hoybin.github.io/categories/JavaScript/"/>
    
    
      <category term="javascript" scheme="http://hoybin.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 数据类型</title>
    <link href="http://hoybin.github.io/archive/20180514-6f8b515b.html"/>
    <id>http://hoybin.github.io/archive/20180514-6f8b515b.html</id>
    <published>2018-05-14T03:26:34.000Z</published>
    <updated>2019-02-01T06:36:13.030Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 中定义了 5 种基本数据类型和 1 种复杂数据类型：</p><ul><li><p>基本类型：Undefined、Null、Number、String、Boolean</p></li><li><p>复杂类型：Object</p></li></ul><p>首先认识一下<strong>类型检测</strong>操作符<code>typeof</code>，这个操作符以字符串形式返回操作数的类型，对于任何一个操作数 <code>x</code> 执行：<code>typeof x</code>，可能的返回结果如下：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;undefined&quot; ··········· 未定义</span><br><span class="line">&quot;boolean&quot; ············· 布尔</span><br><span class="line">&quot;number&quot; ·············· 数值</span><br><span class="line">&quot;string&quot; ·············· 字符串</span><br><span class="line">&quot;object&quot; ·············· 对象</span><br><span class="line">&quot;function&quot; ············ 函数</span><br></pre></td></tr></table></figure><p>示例？别着急，接着往下看，马上就有~</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><h3 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h3><p>Undefined 类型的数据只有一个取值：undefined，用来表示<strong>未初始化的变量</strong>，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name === <span class="string">'undefined'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="未声明的变量"><a href="#未声明的变量" class="headerlink" title="未声明的变量"></a>未声明的变量</h4><p>未声明的变量必然也是未初始化的，所以如果 <code>x</code> 没有使用 <code>var</code> 关键字声明过，执行 <code>typeof x</code> 返回结果也是 <code>undefined</code>，除此之外，对于未声明的变量执行其他任何操作均会导致错误。下面第一行代码会引发错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(age);  <span class="comment">// ReferenceError: age is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> age);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>不管是未声明的变量还是未初始化的变量，其值（一个不存在，一个未赋值）参与运算是没有实际意义的。因此有如下<strong>建议</strong>：</p><ul><li>任何时候在使用变量前都要初始化，那么在 typeof 操作返回 undefined 值时就能知道这个变量还未声明而不是未初始化。</li><li>任何时候不要对变量显式赋值 undefined，<code>var x = undefined</code> 没有意义。</li></ul><h3 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h3><p>Null 类型的数据也只有一个取值：null，用来表示一个空对象指针，通常用来初始化一个将要存放对象的变量，所以在使用 typeof 操作符检测 null 值时将返回 object，即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person); <span class="comment">// object;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person === <span class="string">'object'</span>); <span class="comment">//true;</span></span><br></pre></td></tr></table></figure><p><strong>建议</strong>：如果一个变量准备用于保存对象，那么应该初始化为 null 值。之后，只要检查 null 就可以确定变量中是否已经保存了一个对象的引用，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(person !== null) &#123;</span><br><span class="line">    // 执行对 person 对象的操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其另外一层含义是：变量的<strong>初始化值</strong>和将来要<strong>存储的值</strong>最好能够保持数据类型一致，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">''</span>; <span class="comment">// 字符串类型变量，不建议 var string = null;</span></span><br><span class="line"><span class="keyword">var</span> number = <span class="number">0</span>; <span class="comment">// 数值类型变量，不建议 var number = null;</span></span><br><span class="line"><span class="keyword">var</span> boolean = <span class="literal">false</span>; <span class="comment">// 布尔类型变量，不建议 var boolean = null;</span></span><br></pre></td></tr></table></figure><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>逻辑型数据包含两个值：true 和 false，不需要加引号。</p><p>参与逻辑运算的值会被<strong>自动转换为逻辑类型值</strong>，其中：<code>&quot;&quot;（空字符串）</code>、<code>null</code>、<code>undefined</code>、<code>0（数值 0）</code>、<code>NaN</code>、<code>false</code> 6 个值会被转换为<code>false</code>，其他所有数据都会被转换为<code>true</code>。</p><p>借助自动类型转换，可以很轻易地使用<strong>双重取反操作</strong>将任何值转换为相应的布尔值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(!!<span class="number">2008</span>); <span class="comment">// true;</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="string">'Hello'</span>); <span class="comment">// true;</span></span><br></pre></td></tr></table></figure><p>如果 JavaScript 引擎在<code>&amp;&amp;</code>和<code>||</code>表达式中遇到一个非布尔类型的操作数，那么该操作数的值就会成为该表达式所返回的结果。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> || <span class="string">'hello'</span>); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>由于 JavaScript 采用 IEEE754（底层的东西） 格式表示数值，对于浮点数的计算只能给出近似值，因此下面的代码执行结果是不符合逻辑的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="无穷"><a href="#无穷" class="headerlink" title="无穷"></a>无穷</h4><p>如果计算结果超出机器表示范围，将被自动转换为特殊值：<code>Infinity（正无穷）</code>，<code>-Infinity（负无穷）</code>，这两个值无法参数任何计算。如果不是进行大数值计算，一般也很少碰到，用到的时候去查资料吧。</p><h4 id="非数值"><a href="#非数值" class="headerlink" title="非数值"></a>非数值</h4><p>如果一个要返回数值的操作数未返回数值，将被自动转换为特殊值 <code>NaN（Not a Number）</code>。NaN 具有以下特性：</p><ol><li>任何 NaN 参与的操作，其结果为 NaN</li><li>NaN 与任何值都不相等，包括其自身</li></ol><p>验证如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> * <span class="number">0</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>所以如果计算结果为 NaN，请检查代码中是否有非数值类型的数据参与数学计算。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>表示由零或多个 16 位 Unicode 字符组成的字符序列。表示字符串的时候需要使用引号包裹，单引号和双引号都可以。如下代码等效效：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg1 = <span class="string">'Hello, world'</span>;</span><br><span class="line"><span class="keyword">var</span> msg2 = <span class="string">"Hello, world"</span>;</span><br></pre></td></tr></table></figure><h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p>和大多数语言一样使用 <code>\</code> 进行转义。我们用到的最多的也就是：<code>\n</code>，<code>\&#39;</code>，<code>\&quot;</code>，其它极少用到，用时去查。</p><h4 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h4><ul><li>字符串与任何非字符串值相加，此非字符串值在计算时都会被转换为字符串类型的值；</li><li>在除了加法运算之外的算术运算中，字符串在计算时会被转换为数值类型的值。</li></ul><h2 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h2><h3 id="Object-根对象"><a href="#Object-根对象" class="headerlink" title="Object(根对象)"></a>Object(根对象)</h3><p>之所以称为根对象是因为 Object 对象是所有其他对象的祖先对象，不管是内置对象还是自定义对象，其继承链的最顶端总是 Object 对象。</p><p>JavaScript 中没有类，而是使用构造函数（或者叫构造器）创建对象，构造函数和对象同名，如 Object() 用来创建 Object 对象。创建对象的语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><p>另外一种创建 Object 对象的语法是使用<strong>字面量</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>以上两种方式完全等价，实践中，字面量方式更加简洁明了，所以比较推荐使用这种方式创建对象。上面的代码创建了一个空对象 <code>o</code>，它是 Object 对象的实例。之后可以为其添加属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">o.name = <span class="string">'js'</span>;</span><br><span class="line">o.echo = <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>除了 Object 之外，JavaScript 内置的对象还有：Array、Number、String、Boolean、Date、RegExp、Math、Function，除了 Math 之外，全部继承自 Object。简要说明如下：</p><ul><li><strong>Array</strong><br>  用于创建数组对象</li><li><strong>Number</strong>、<strong>String</strong>、<strong>Boolean</strong><br>  分别是其对应的基本类型数据的包装对象</li><li><strong>Date</strong><br>  提供日期时间功能，与 Java 类似，JavaScript 中的时间戳以毫秒为单位</li><li><strong>RegExp</strong><br>  提供正则表达式的功能</li><li><strong>Math</strong><br>  是个单例对象，以静态方法形式提供数学相关的计算功能</li><li><strong>Function</strong><br>  没错，函数是一种对象</li></ul><h2 id="变量传值"><a href="#变量传值" class="headerlink" title="变量传值"></a>变量传值</h2><p>JavaScript 中所有类型的变量全部<strong>按值传递</strong> —— 基本类型的变量中存储的是数据本身，所以传递的是数据的副本；而对象变量中存储的是一个指针（数据在内存中的起始地址），所以递的是指针的副本（也可以理解为按引用传递，说法不同而以）。这将导致基本类型的变量和对象类型的变量在复制和参数传递时的行为差异：</p><h3 id="传递数据副本"><a href="#传递数据副本" class="headerlink" title="传递数据副本"></a>传递数据副本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">'apple'</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = str1; <span class="comment">// &lt;----------------------</span></span><br><span class="line">str1 = <span class="string">'oringe'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str1); <span class="comment">// oringe</span></span><br><span class="line"><span class="built_in">console</span>.log(str2); <span class="comment">// apple</span></span><br></pre></td></tr></table></figure><h3 id="传递指针副本"><a href="#传递指针副本" class="headerlink" title="传递指针副本"></a>传递指针副本</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1, person2;</span><br><span class="line">person1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person1.name = <span class="string">'Leo'</span>;</span><br><span class="line">person2 = person1; <span class="comment">// &lt;----------------------</span></span><br><span class="line">person2.name = <span class="string">'Jack'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1.name); <span class="comment">// Jack</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 中定义了 5 种基本数据类型和 1 种复杂数据类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基本类型：Undefined、Null、Number、String、Boolean&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;复杂类型：Object&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先认识一下&lt;strong&gt;类型检测&lt;/strong&gt;操作符&lt;code&gt;typeof&lt;/code&gt;，这个操作符以字符串形式返回操作数的类型，对于任何一个操作数 &lt;code&gt;x&lt;/code&gt; 执行：&lt;code&gt;typeof x&lt;/code&gt;，可能的返回结果如下：&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://hoybin.github.io/categories/JavaScript/"/>
    
    
      <category term="javascript" scheme="http://hoybin.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 极简史</title>
    <link href="http://hoybin.github.io/archive/20180506-b54d253b.html"/>
    <id>http://hoybin.github.io/archive/20180506-b54d253b.html</id>
    <published>2018-05-06T09:42:07.000Z</published>
    <updated>2019-02-01T06:36:13.030Z</updated>
    
    <content type="html"><![CDATA[<p>大多数关于 JavaScript 的书都会在开头用很大的篇幅讲述 JavaScrpt 的发展历史以及 JavaScipt 如何从屌丝逆袭成为高富帅，进而成为互联网第一语言的传奇往事。一方面是因为书的定价跟厚度多少有点关系，更重要的原因是其历史也确实有点儿意思。</p><p>在我看来，JavaScript 的历史从另一个角度反映了互联网技术的演化与进步，其在 Web 邻域中的作用和地位无可替代，了解它的历史对于我们学习和掌握 Web 开发有一定的积极意义，因此，我们有必要来挖一挖 JavaScript 的历史，看看有什么宝贝。</p><a id="more"></a><h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>1995 年，Internet 刚刚起步，当网上冲浪越来越流行时，对于开发客户端脚本的需求也逐渐增大。此时，大部分因特网用户还仅仅通过 28.8 kbit/s 的调制解调器连接到网络，即便这时网页已经不断地变得更大和更复杂。而更加加剧用户痛苦的是，仅仅为了简单的表单有效性验证，就要与服务器进行多次地往返交互。设想一下，用户填完一个表单，点击提交按钮，等待了 30 秒的处理后，看到的却是一条告诉你忘记填写一个必要的字段。</p><p>Netscape 在当时是一家很牛逼的公司，它的创始团队来自 NCSA（美国国家超级计算机应用中心）。作为正处于技术革新最前沿的开拓者，Netscape 开始考虑开发一种客户端脚本语言来解决此类简单的交互问题，这种语言最初被命名为 Mocha。</p><h2 id="决策"><a href="#决策" class="headerlink" title="决策"></a>决策</h2><p>1995 年还发生了另外一件大事：另外一家很牛逼的公司 Sun 将 Oak 语言改名为 Java，正式向市场推出。Sun 公司大肆宣传，许诺这种语言可以 “一次编写，到处运行”（Write Once, Run Anywhere），它看上去很可能成为未来的主宰。</p><p>Netscape 对 Java 很是心动，随即与 Sun 达成一项协议，让 Java（以 applet 的形式）可以直接在浏览器中运行。那么为什么要开发 Mocha（JavaScript 早期的名字）呢？为什么已经有了 Java，却还要开发一个全新的语言呢？当时的想法是，Java 不适合 Mocha 的目标受众：测试脚本编写人员、业余爱好者、设计师。对于用在浏览器这个角色上来说，Java 确实太大太重了。也就是说，Mocha 命中注定就是 Java 的脚本同伴，在某种程度上类似于 Windows 平台上 C/C++ 和 Visual Basic 之间的关系。</p><p>1995 年 5 月，Netscape 与 Sun 联盟，共同推进项目研发，并再次将 Mocha 改名为 LiveScript。受 Java 影响，研发团队最后决定：LiveScript 必须 “看上去与 Java 足够相似”，但是比 Java 简单。</p><h2 id="杂交"><a href="#杂交" class="headerlink" title="杂交"></a>杂交</h2><p>这个项目最终被交由 Brendan Eich 负责设计实现，但是，他对 Java 一点兴趣也没有。为了应付公司安排的任务，他只用 10 天时间就把 JavaScript 设计出来了。其设计思路是这样的：</p><ol><li>借鉴 C 语言的基本语法；</li><li>借鉴 Java 语言的数据类型和内存管理；</li><li>借鉴 Scheme 语言，将函数提升到 “第一等公民”（first class）的地位；</li><li>借鉴 Self 语言，使用基于原型（prototype）的继承机制。</li></ol><p>所以，Javascript 语言实际上是两种语言风格的混合产物 ——（简化的）函数式编程 +（简化的）面向对象编程。</p><h2 id="横空出世"><a href="#横空出世" class="headerlink" title="横空出世"></a>横空出世</h2><p>1996 年 3 月，LiveScript 再次改名为 JavaScript 并随同 Netscape Navigator 2.0 版正式发布，JavaScript 1.0 问世。</p><p>从此，Web 江湖血雨腥风！</p><h2 id="狭路相逢"><a href="#狭路相逢" class="headerlink" title="狭路相逢"></a>狭路相逢</h2><p>JavaScript 1.0 取得了巨大成功，紧接着，Netscape 在其 Navigator 3.0 中发布了 JavaScript 1.1，当时 Windows 95 风头正劲，微软也看到了 JavaScript 的潜力，随即在 IE 3.0 版本中嵌入了 JavaScript 的克隆版 JScript。为了抢占市场，两种 JavaScript 很多实现互不兼容，一场由 JavaScript 引发的战争由此开始，史称 “浏览器大战”。</p><p>其时，除了 Netscape 的 Navigator 和微软的 IE，还有 CEnvi 的 ScriptEase，只是 CEnvi 市场占有率很低，实际战争的主角就成了 Navigator 和 IE。</p><p>随着浏览器版本升级，战火愈演愈烈，技术变革一次又一次地提升了 Web 浏览的用户体验，当吃瓜群众们沉浸在这种前所未有的高潮中时，前端程序猿们却挣扎在水深火热之中。为了兼容不同浏览器而不得不写出各种奇奇怪怪的代码，由此产生的各种 hack 及浏览器臭探技术层出不穷，更极端的情况是为相同的功能写两份甚至多份不同的实现。可想而知：开发效率极低，且维护成本极高。IE 浏览器因为有 Windows 这个有钱的老爸，常常不按套路出牌，搞得前端程序猿们死去活来，叫苦连天！其中 IE 6 最为臭名远扬，以至于后来，前端程序猿们每次碰到兼容 IE 6 的时候都有种 “被强奸” 的感觉！</p><h2 id="标准化之路"><a href="#标准化之路" class="headerlink" title="标准化之路"></a>标准化之路</h2><p>无法无天的局面显然阻碍了行业的发展，标准化势在必行。</p><p>1997 年，带头大哥 Netscape 将 JavaScript 1.1 作为蓝本提交给 ECMA（欧洲计算机制造商协会），希望确立 JavaScript 的行业标准。该协会指定 39 号技术委员会（Technical Committee 39，简称 TC39）负责将其进行标准化，TC39 由来此各大公司以及其他关注脚本语言发展的公司的程序员组成，经过数月的努力完成了 ECMA-262 —— 定义了一种名为 ECMAScript 的新脚本语言的标准。</p><p>第二年，ISO/IEC（国标标准化组织和国际电工委员会）也采用了 ECMAScript 作为标准（即ISO/IEC-16262）。</p><p>即便是在标准诞生以后， “浏览器大战” 所遗留的问题依然存在，因为世界上依然有人在使用老版本的浏览器，浏览器兼容问题也不会在短期内彻底被消除。</p><h2 id="版本略表"><a href="#版本略表" class="headerlink" title="版本略表"></a>版本略表</h2><h3 id="ECMAScript-1"><a href="#ECMAScript-1" class="headerlink" title="ECMAScript 1"></a>ECMAScript 1</h3><p>1997 年 6 月发布：本质上与 javascript 1.1 相同，只不过删除了所有针对浏览器的代码并作了一些较小的改动。</p><h3 id="ECMAScript-2"><a href="#ECMAScript-2" class="headerlink" title="ECMAScript 2"></a>ECMAScript 2</h3><p>1998 年 6 月发布：这一版的内容更新是为了与 ISO/IEC-16262 保持严格一致，没有作任何新增、修改或删节处理。</p><h3 id="ECMAScript-3"><a href="#ECMAScript-3" class="headerlink" title="ECMAScript 3"></a>ECMAScript 3</h3><p>1999 年 12 月发布：新增了对正则表达式、新控制语句、try-catch 异常处理的支持，修改了字符处理、错误定义和数值输出等内容。从各方面综合来看，第3版标志着 ECMAScript 成为了一门真正的编程语言。也成为 JavaScript 的通行标准，得到了广泛支持。</p><h3 id="ECMAScript-4"><a href="#ECMAScript-4" class="headerlink" title="ECMAScript 4"></a>ECMAScript 4</h3><p>2007 年 10 月发布：ECMAScript 4.0 版草案</p><p>草案发布后，由于 4.0 版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA 开会决定，中止 ECMAScript 4.0 的开发（即废除了这个版本）。</p><p>将其中涉及现有功能改善的一小部分，发布为 ECMAScript3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。</p><p>会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。</p><h3 id="ECMAScript-5"><a href="#ECMAScript-5" class="headerlink" title="ECMAScript 5"></a>ECMAScript 5</h3><p>2009 年 12 月发布：ECMAScript5 与 ECMAScript3 基本保持兼容，较大的语法修正和新功能加入，将由 JavaScript.next 完成（当时，JavaScript.next 指的是 ECMAScript 6 。第六版发布以后，将指 ECMAScript 7）。该版本力求澄清第 3 版中的歧义，并添加了新的功能。</p><h4 id="ECMAscript-5-1"><a href="#ECMAscript-5-1" class="headerlink" title="ECMAscript 5.1"></a>ECMAscript 5.1</h4><p>2011 年 6 月发布: 并且成为 ISO 国际标准（ISO/IEC16262:2011）。到了 2012 年底，所有主要浏览器都支持 ECMAScript 5.1 版的全部功能</p><h3 id="ECMAScript-6"><a href="#ECMAScript-6" class="headerlink" title="ECMAScript 6"></a>ECMAScript 6</h3><p>2015 年 6 月发布：ECMAScript 6 正式发布，并且更名为 ECMAScript 2015。</p><p>这是因为 TC39 委员会计划，以后每年发布一个 ECMAScirpt 的版本，下一个版本在 2016 年发布，称为 ECMAScript 2016。此后，新版本将按照 <strong>ECMAScript + 年份</strong> 的形式发布。</p><p>ES6 是继 ES5 之后的一次主要改进，语言规范由 ES5.1 时代的 245 页扩充至 600 页。尽管 ES6 做了大量的更新，但是它依旧完全向后兼容以前的版本。此版本增添了许多必要的特性，新功能包括：模块和类以及一些实用特性，例如 Maps、Sets、Promises、生成器（Generators）等。</p><h2 id="阿贾克斯"><a href="#阿贾克斯" class="headerlink" title="阿贾克斯"></a>阿贾克斯</h2><p>Ajax，即异步 JavaScript 和 XML，是一种在 ECMAScript 3 年代诞生的技术。虽然它并非标准的一部分，不过微软为其 IE5 浏览器实现了某些对 JavaScript 的扩展。其中之一就是 XMLHttpRequest 功能（以 XMLHTTP ActiveX 控件的形式）。该功能允许浏览器执行对服务器的异步 HTTP 请求，从而允许页面被即时动态更新。</p><p>这种技术最早在 1998 年由微软发明，但并未引起人们的注意。直到 2005 年，Google 在它著名的交互应用程序中使用了异步通讯，如 Google、Google 地图、Google 搜索、Gmail 等。Ajax 这个词由《Ajax: A New Approach to Web Applications》一文所创，该文的迅速流传提高了人们使用该项技术的意识。</p><p>Ajax 的出现是 Web 技术的一次革命，它完全颠覆了传统的浏览器交互体验，让 JavaScript 走上了语言巅峰，再次风光无限。</p><h2 id="露的姬爱死"><a href="#露的姬爱死" class="headerlink" title="露的姬爱死"></a>露的姬爱死</h2><p>Nodejs 诞生于 2009 年，我说它是 JavaScript “同母异父” 的弟弟应该没人反对。因为 Nodejs 和 JavaScript 都源于 ECMAScript，它们都是对 ECMAScript 标准的具体实现，但却是由不同的人发明创建：Nodejs 的爸爸是 Ryan Dahl；JavaScript 的爸爸是 Brendan Eich。</p><p>Nodejs 这个二胎的诞生并不是为了取代 JavaScript，而是为了攻占新的领地 —— 服务器。JavaScript 虽然历经坎坷，但已然在浏览器端一统江湖，而 Nodejs 在服务器端搞得也是风生水起，抢占了不少 PHP，Java 等老牌服务端语言的地盘。相比 JavaScript 坎坷的成长之路，Nodejs 的发展算是顺风顺水，前途亦是不可限量。</p><h2 id="兄弟联手"><a href="#兄弟联手" class="headerlink" title="兄弟联手"></a>兄弟联手</h2><p>正因 Nodejs 和 JavaScript 宿主不同，它们的功能及扩展也不尽相同，如下图所示：</p><p><img src="/archive/20180506-b54d253b/ecmascript.png" alt="JavaScript, Nodejs 和 ECMAScript 之间的关系" title="JavaScript, Nodejs 和 ECMAScript 之间的关系"></p><p>虽是兄弟，但 Nodejs 和 JavaScript 各自运行在不同的环境中，相望于 HTTP 协议的两端，所以它们不会有任何冲突，反而配合地天衣无缝。也因此，使得 JavaScript 全栈架构成为 Web 应用的另一种选择。</p><hr><p>声明：</p><ol><li>本文部分内容参考自互联网和各种书籍，在此不一一列举，如有侵权，请无论如何、想方设法、不惜一切代价地告知本人，我将在第一时间处理以保证您的合法权益不受侵犯；</li><li>本文中某些历史事件的准确性未作考证，如有错漏，恕我不能及时纠正，请看官们谅解，同时希望阅读本文对您的学习有所帮助。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大多数关于 JavaScript 的书都会在开头用很大的篇幅讲述 JavaScrpt 的发展历史以及 JavaScipt 如何从屌丝逆袭成为高富帅，进而成为互联网第一语言的传奇往事。一方面是因为书的定价跟厚度多少有点关系，更重要的原因是其历史也确实有点儿意思。&lt;/p&gt;
&lt;p&gt;在我看来，JavaScript 的历史从另一个角度反映了互联网技术的演化与进步，其在 Web 邻域中的作用和地位无可替代，了解它的历史对于我们学习和掌握 Web 开发有一定的积极意义，因此，我们有必要来挖一挖 JavaScript 的历史，看看有什么宝贝。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://hoybin.github.io/categories/JavaScript/"/>
    
    
      <category term="javascript" scheme="http://hoybin.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>
